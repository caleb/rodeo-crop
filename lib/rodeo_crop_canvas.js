// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var CanvasImage, CropBox, Drawable, Rectangle, Stage, type, _, _fn, _i, _len, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = {};

  _.extend = function(obj, source) {
    var prop;
    if (source) {
      for (prop in source) {
        obj[prop] = source[prop];
      }
    }
    return obj;
  };

  _ref = ['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'];
  _fn = function(type) {
    return _["is" + type] = function(obj) {
      return Object.prototype.toString.call(obj) === ("[object " + type + "]");
    };
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    type = _ref[_i];
    _fn(type);
  }

  Drawable = (function() {
    function Drawable(options) {
      this.options = options;
      this.x = options.x;
      this.y = options.y;
      this.w = options.w;
      this.h = options.h;
      this.scale = options.scale;
      this.parent = options.parent;
      this.canvas = options.canvas;
      this.children = options.children || [];
      this.dragable = options.dragable || false;
    }

    Drawable.prototype.onCanvasSizeChange = function() {
      if (_.isFunction(this.options.onCanvasSizeChange)) {
        return this.options.onCanvasSizeChange.call(this);
      }
    };

    Drawable.prototype.set = function(options) {
      var key, value, _results;
      _results = [];
      for (key in options) {
        if (!__hasProp.call(options, key)) continue;
        value = options[key];
        _results.push(this[key] = value);
      }
      return _results;
    };

    Drawable.prototype.bounds = function() {
      return {
        x: 0,
        y: 0,
        w: this.w,
        h: this.h
      };
    };

    Drawable.prototype.frame = function() {
      return {
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h
      };
    };

    Drawable.prototype.convertToParent = function(point) {
      var frame;
      frame = this.frame();
      return {
        x: point.x + frame.x,
        y: point.y + frame.y
      };
    };

    Drawable.prototype.convertFromParent = function(point) {
      var frame;
      frame = this.frame();
      return {
        x: point.x - frame.x,
        y: point.y - frame.y
      };
    };

    Drawable.prototype.convertToCanvas = function(point) {
      var parent, x, y;
      parent = this;
      x = point.x;
      y = point.y;
      while (parent) {
        x += parent.frame().x;
        y += parent.frame().y;
        parent = parent.parent;
      }
      return {
        x: x,
        y: y
      };
    };

    Drawable.prototype.convertFromCanvas = function(point) {
      var parent, x, y;
      parent = this;
      x = point.x;
      y = point.y;
      while (parent) {
        x -= parent.frame().x;
        y -= parent.frame().y;
        parent = parent.parent;
      }
      return {
        x: x,
        y: y
      };
    };

    Drawable.prototype.positionContext = function(ctx, fn) {
      var pos;
      if (this.parent) {
        pos = this.convertToCanvas(this.parent.bounds());
        ctx.translate(pos.x, pos.y);
      }
      return fn.call(this, ctx);
    };

    Drawable.prototype.isolateAndMoveToParent = function(ctx, fn) {
      ctx.save();
      this.positionContext(ctx, function(ctx) {
        return fn.call(this, ctx);
      });
      return ctx.restore();
    };

    Drawable.prototype.containsCanvasPoint = function(point) {
      var localPoint;
      localPoint = this.convertFromCanvas(point);
      return this.containsPoint(localPoint);
    };

    Drawable.prototype.containsPoint = function(point) {
      var frame, _ref1, _ref2;
      frame = this.frame();
      return (0 <= (_ref1 = point.x) && _ref1 <= frame.w) && (0 <= (_ref2 = point.y) && _ref2 <= frame.h);
    };

    Drawable.prototype.addChild = function(child) {
      child.parent = this;
      return this.children.push(child);
    };

    Drawable.prototype.removeChild = function(child) {
      var i;
      i = this.children.indexOf(child);
      if (i >= 0) {
        child.parent = null;
        return this.children.splice(i, 1);
      }
    };

    Drawable.prototype.drawChildren = function(ctx) {
      var child, _j, _len1, _ref1, _results;
      _ref1 = this.children;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        child = _ref1[_j];
        _results.push(child.draw(ctx));
      }
      return _results;
    };

    Drawable.prototype.draw = function(ctx) {};

    return Drawable;

  })();

  CanvasImage = (function(_super) {
    __extends(CanvasImage, _super);

    function CanvasImage(options) {
      CanvasImage.__super__.constructor.call(this, options);
      this.source = options.source;
      this.naturalWidth = options.naturalWidth;
      this.naturalHeight = options.naturalHeight;
      this.onLoad = options.onLoad;
      this.loadImage();
    }

    CanvasImage.prototype.naturalBounds = function() {
      return {
        x: 0,
        y: 0,
        w: this.naturalWidth,
        h: this.naturalHeight
      };
    };

    CanvasImage.prototype.resizeToParent = function() {
      var ch, cw, scaleX, scaleY;
      cw = this.parent.frame().w;
      ch = this.parent.frame().h;
      scaleX = 1;
      scaleY = 1;
      if (this.naturalWidth > cw) {
        scaleX = cw / this.naturalWidth;
      }
      if (this.naturalHeight > ch) {
        scaleY = ch / this.naturalHeight;
      }
      this.scale = Math.min(scaleX, scaleY);
      this.w = (this.naturalWidth * this.scale) | 0;
      return this.h = (this.naturalHeight * this.scale) | 0;
    };

    CanvasImage.prototype.centerOnParent = function() {
      this.x = ((this.parent.frame().w / 2) - (this.w / 2)) | 0;
      return this.y = ((this.parent.frame().h / 2) - (this.h / 2)) | 0;
    };

    CanvasImage.prototype.draw = function(ctx) {
      this.isolateAndMoveToParent(ctx, function(ctx) {
        return ctx.drawImage(this.img, 0, 0, this.w, this.h);
      });
      return this.drawChildren(ctx);
    };

    CanvasImage.prototype.onCanvasSizeChange = function() {
      var child, _j, _len1, _ref1, _results;
      CanvasImage.__super__.onCanvasSizeChange.call(this);
      _ref1 = this.children;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        child = _ref1[_j];
        _results.push(child.onCanvasSizeChange());
      }
      return _results;
    };

    CanvasImage.prototype.loadImage = function() {
      var _this = this;
      this.img = document.createElement('img');
      this.img.onload = function() {
        _this.naturalWidth = _this.img.naturalWidth;
        _this.naturalHeight = _this.img.naturalHeight;
        if (_.isFunction(_this.onLoad)) {
          return _this.onLoad.call(_this);
        }
      };
      return this.img.src = this.source;
    };

    return CanvasImage;

  })(Drawable);

  Rectangle = (function(_super) {
    __extends(Rectangle, _super);

    function Rectangle(options) {
      Rectangle.__super__.constructor.call(this, options);
      this.fillStyle = options.fillStyle || 'rgba(0, 0, 0, 0)';
      this.strokeStyle = options.strokeStyle;
      this.lineWidth = options.lineWidth;
    }

    Rectangle.prototype.draw = function(ctx) {
      var _this = this;
      return this.isolateAndMoveToParent(ctx, function(ctx) {
        if (_this.fillStyle) {
          ctx.fillStyle = _this.fillStyle;
        }
        if (_this.strokeStyle) {
          ctx.strokeStyle = _this.strokeStyle;
        }
        if (_this.lineWidth) {
          ctx.lineWidth = _this.lineWidth;
        }
        ctx.beginPath();
        ctx.rect(0, 0, _this.w, _this.h);
        ctx.closePath();
        if (_this.fillStyle) {
          ctx.fill();
        }
        if (_this.lineWidth && _this.strokeStyle) {
          return ctx.stroke();
        }
      });
    };

    return Rectangle;

  })(Drawable);

  CropBox = (function(_super) {
    __extends(CropBox, _super);

    function CropBox(options) {
      CropBox.__super__.constructor.call(this, _.extend({
        dragable: true
      }, options));
      this.image = options.image;
      this.handleSize = options.handleSize || 10;
      this.screenStyle = options.screenStyle || 'rgba(0, 0, 0, .75)';
      this.topScreen = new Rectangle({
        fillStyle: this.screenStyle
      });
      this.leftScreen = new Rectangle({
        fillStyle: this.screenStyle
      });
      this.rightScreen = new Rectangle({
        fillStyle: this.screenStyle
      });
      this.bottomScreen = new Rectangle({
        fillStyle: this.screenStyle
      });
      this.cropX = options.cropX || 0;
      this.cropY = options.cropY || 0;
      this.cropWidth = options.cropWidth || this.handleSize * 4;
      this.cropHeight = options.cropHeight || this.handleSize * 4;
      this.onCropFrameChanged = options.onCropFrameChanged || null;
      this.dragging = null;
      this.handles = {};
    }

    CropBox.prototype.frame = function() {
      return {
        x: this.w < 0 ? this.x + this.w : this.x,
        y: this.h < 0 ? this.y + this.h : this.y,
        w: Math.abs(this.w),
        h: Math.abs(this.h)
      };
    };

    CropBox.prototype.cropFrame = function() {
      return {
        x: this.cropX,
        y: this.cropY,
        width: this.cropWidth,
        height: this.cropHeight
      };
    };

    CropBox.prototype.updateCropAreaFromFrame = function() {
      var frame, imageBounds, naturalBounds;
      frame = this.frame();
      naturalBounds = this.image.naturalBounds();
      imageBounds = this.image.bounds();
      if (imageBounds.w && imageBounds.h) {
        this.cropX = Math.round(naturalBounds.w * (frame.x / imageBounds.w));
        this.cropY = Math.round(naturalBounds.h * (frame.y / imageBounds.h));
        this.cropWidth = Math.round(naturalBounds.w * (frame.w / imageBounds.w));
        this.cropHeight = Math.round(naturalBounds.h * (frame.h / imageBounds.h));
      }
      return typeof this.onCropFrameChanged === "function" ? this.onCropFrameChanged(this.cropFrame()) : void 0;
    };

    CropBox.prototype.setFrameAndUpdateCropArea = function(frame) {
      this.x = frame.x;
      this.y = frame.y;
      this.w = frame.w;
      this.h = frame.h;
      return this.updateCropAreaFromFrame();
    };

    CropBox.prototype.updateFrameFromCropArea = function() {
      var imageBounds, naturalBounds;
      naturalBounds = this.image.naturalBounds();
      imageBounds = this.image.bounds();
      if (imageBounds.w && imageBounds.h) {
        this.x = Math.round(imageBounds.w * (this.cropX / naturalBounds.w));
        this.y = Math.round(imageBounds.h * (this.cropY / naturalBounds.h));
        this.w = Math.round(imageBounds.w * (this.cropWidth / naturalBounds.w));
        return this.h = Math.round(imageBounds.h * (this.cropHeight / naturalBounds.h));
      }
    };

    CropBox.prototype.setCropAreaAndUpdateFrame = function(cropArea) {
      this.cropX = cropArea.x;
      this.cropY = cropArea.y;
      this.cropWidth = cropArea.width;
      this.cropHeight = cropArea.height;
      return this.updateFrameFromCropArea();
    };

    CropBox.prototype.bounds = function() {
      return {
        x: 0,
        y: 0,
        w: Math.abs(this.w),
        h: Math.abs(this.h)
      };
    };

    CropBox.prototype.onCanvasSizeChange = function() {
      return this.updateFrameFromCropArea();
    };

    CropBox.prototype.containsCanvasPoint = function(point) {
      var containsPoint, direction, handle, local, _ref1;
      local = this.convertFromCanvas(point);
      containsPoint = this.containsPoint(local);
      if (containsPoint) {
        return containsPoint;
      }
      _ref1 = this.handles;
      for (direction in _ref1) {
        handle = _ref1[direction];
        if (handle.containsCanvasPoint(point)) {
          return true;
        }
      }
      return false;
    };

    CropBox.prototype.onMouseOut = function(point) {
      return this.canvas.style.cursor = 'default';
    };

    CropBox.prototype.onMouseMove = function(point) {
      var direction, handle, _ref1;
      _ref1 = this.handles;
      for (direction in _ref1) {
        handle = _ref1[direction];
        if (handle.containsCanvasPoint(point)) {
          switch (direction) {
            case 'tl':
              this.canvas.style.cursor = 'nw-resize';
              break;
            case 'tm':
              this.canvas.style.cursor = 'n-resize';
              break;
            case 'tr':
              this.canvas.style.cursor = 'ne-resize';
              break;
            case 'ml':
              this.canvas.style.cursor = 'w-resize';
              break;
            case 'mr':
              this.canvas.style.cursor = 'e-resize';
              break;
            case 'bl':
              this.canvas.style.cursor = 'sw-resize';
              break;
            case 'bm':
              this.canvas.style.cursor = 's-resize';
              break;
            case 'br':
              this.canvas.style.cursor = 'se-resize';
          }
          return;
        }
      }
      return this.canvas.style.cursor = 'move';
    };

    CropBox.prototype.constrainPointInParent = function(point) {
      return {
        x: Math.min(Math.max(point.x, 0), this.parent.frame().w),
        y: Math.min(Math.max(point.y, 0), this.parent.frame().h)
      };
    };

    CropBox.prototype.onMouseDown = function(point) {};

    CropBox.prototype.onMouseUp = function(point) {
      return this.dragging = null;
    };

    CropBox.prototype.onDragStart = function(point) {
      var direction, handle, localPoint, _ref1;
      _ref1 = this.handles;
      for (direction in _ref1) {
        handle = _ref1[direction];
        if (handle.containsCanvasPoint(point)) {
          localPoint = handle.convertFromCanvas(point);
          this.dragging = {
            resizeDirection: direction,
            object: handle,
            offsetX: localPoint.x,
            offsetY: localPoint.y
          };
          return;
        }
      }
      localPoint = this.convertFromCanvas(point);
      return this.dragging = {
        object: this,
        offsetX: localPoint.x,
        offsetY: localPoint.y
      };
    };

    CropBox.prototype.onDragMove = function(point) {
      var localPoint, parentPoint, _ref1, _ref2;
      if (((_ref1 = this.dragging) != null ? _ref1.object : void 0) === this) {
        localPoint = this.convertFromCanvas(point);
        this.moveTo({
          x: localPoint.x - this.dragging.offsetX,
          y: localPoint.y - this.dragging.offsetY
        });
        return this.updateCropAreaFromFrame();
      } else if ((_ref2 = this.dragging) != null ? _ref2.resizeDirection : void 0) {
        parentPoint = this.parent.convertFromCanvas(point);
        switch (this.dragging.resizeDirection) {
          case 'tl':
            point = this.constrainPointInParent(parentPoint);
            this.w = this.w + (this.x - point.x);
            this.h = this.h + (this.y - point.y);
            this.x = point.x;
            this.y = point.y;
            break;
          case 'tm':
            point = this.constrainPointInParent(parentPoint);
            this.w = this.w;
            this.h = this.h + (this.y - point.y);
            this.x = this.x;
            this.y = point.y;
            break;
          case 'tr':
            point = this.constrainPointInParent(parentPoint);
            this.w = point.x - this.x;
            this.h = this.h + (this.y - point.y);
            this.x = this.x;
            this.y = point.y;
            break;
          case 'ml':
            point = this.constrainPointInParent(parentPoint);
            this.w = this.w + (this.x - point.x);
            this.h = this.h;
            this.x = point.x;
            this.y = this.y;
            break;
          case 'mr':
            point = this.constrainPointInParent(parentPoint);
            this.w = point.x - this.x;
            this.h = this.h;
            this.x = this.x;
            this.y = this.y;
            break;
          case 'bl':
            point = this.constrainPointInParent(parentPoint);
            this.w = this.w + (this.x - point.x);
            this.h = point.y - this.y;
            this.x = point.x;
            this.y = this.y;
            break;
          case 'bm':
            point = this.constrainPointInParent(parentPoint);
            this.w = this.w;
            this.h = point.y - this.y;
            this.x = this.x;
            this.y = this.y;
            break;
          case 'br':
            point = this.constrainPointInParent(parentPoint);
            this.w = point.x - this.x;
            this.h = point.y - this.y;
            this.x = this.x;
            this.y = this.y;
        }
        return this.updateCropAreaFromFrame();
      }
    };

    CropBox.prototype.onDragEnd = function(point) {
      var frame;
      frame = this.frame();
      this.x = frame.x;
      this.y = frame.y;
      this.w = frame.w;
      return this.h = frame.h;
    };

    CropBox.prototype.onClick = function(point) {};

    CropBox.prototype.moveTo = function(point) {
      var pos, x, y;
      pos = this.convertToParent(point);
      x = Math.max(0, pos.x);
      y = Math.max(0, pos.y);
      x = Math.min(this.parent.bounds().w - this.w, x);
      y = Math.min(this.parent.bounds().h - this.h, y);
      this.x = x;
      return this.y = y;
    };

    CropBox.prototype.drawScreen = function(ctx) {
      var frame;
      frame = this.frame();
      this.topScreen.set({
        parent: this.parent,
        x: 0,
        y: 0,
        w: this.parent.w,
        h: frame.y
      });
      this.bottomScreen.set({
        parent: this.parent,
        x: 0,
        y: frame.y + frame.h,
        w: this.parent.w,
        h: this.parent.h - (frame.y + frame.h)
      });
      this.leftScreen.set({
        parent: this.parent,
        x: 0,
        y: frame.y,
        w: frame.x,
        h: frame.h
      });
      this.rightScreen.set({
        parent: this.parent,
        x: frame.x + frame.w,
        y: frame.y,
        w: this.parent.w - (frame.x + frame.w),
        h: frame.h
      });
      this.topScreen.draw(ctx);
      this.leftScreen.draw(ctx);
      this.rightScreen.draw(ctx);
      return this.bottomScreen.draw(ctx);
    };

    CropBox.prototype.drawHandles = function(ctx) {
      var direction, frame, handle, newRect, _ref1, _results,
        _this = this;
      frame = this.frame();
      newRect = function(x, y) {
        return new Rectangle({
          parent: _this,
          x: x - (_this.handleSize / 2) - 0.5,
          y: y - (_this.handleSize / 2) - 0.5,
          w: _this.handleSize,
          h: _this.handleSize,
          lineWidth: 1,
          strokeStyle: 'rgba(192, 192, 192, 1)',
          fillStyle: 'rgba(64, 64, 64, 1)'
        });
      };
      this.handles["tl"] = newRect(0, 0);
      this.handles["tm"] = newRect(frame.w / 2, 0);
      this.handles["tr"] = newRect(frame.w, 0);
      this.handles["ml"] = newRect(0, frame.h / 2);
      this.handles["mr"] = newRect(frame.w, frame.h / 2);
      this.handles["bl"] = newRect(0, frame.h);
      this.handles["bm"] = newRect(frame.w / 2, frame.h);
      this.handles["br"] = newRect(frame.w, frame.h);
      _ref1 = this.handles;
      _results = [];
      for (direction in _ref1) {
        handle = _ref1[direction];
        _results.push(handle.draw(ctx));
      }
      return _results;
    };

    CropBox.prototype.drawCropLines = function(ctx) {
      var frame, lineDash, opacity,
        _this = this;
      frame = this.frame();
      opacity = "0.5";
      lineDash = 8;
      return this.isolateAndMoveToParent(ctx, function(ctx) {
        var x, y, _j, _k, _len1, _len2, _ref1, _ref2, _results;
        ctx.beginPath();
        ctx.strokeStyle = "rgba(255,255,255," + opacity + ")";
        ctx.rect(0.5, 0.5, frame.w, frame.h);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = "rgba(0,0,0," + opacity + ")";
        ctx.setLineDash([lineDash]);
        ctx.rect(0.5, 0.5, frame.w, frame.h);
        ctx.closePath();
        ctx.stroke();
        _ref1 = [frame.w / 3 + 0.5, (frame.w / 3) * 2 + 0.5];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          x = _ref1[_j];
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.strokeStyle = "rgba(255,255,255," + opacity + ")";
          ctx.setLineDash([]);
          ctx.lineTo(x, frame.h);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.strokeStyle = "rgba(0,0,0," + opacity + ")";
          ctx.setLineDash([lineDash]);
          ctx.lineTo(x, frame.h);
          ctx.stroke();
        }
        _ref2 = [frame.h / 3 + 0.5, (frame.h / 3) * 2 + 0.5];
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          y = _ref2[_k];
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.strokeStyle = "rgba(255,255,255," + opacity + ")";
          ctx.setLineDash([]);
          ctx.lineTo(frame.w, y);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.strokeStyle = "rgba(0,0,0," + opacity + ")";
          ctx.setLineDash([lineDash]);
          ctx.lineTo(frame.w, y);
          _results.push(ctx.stroke());
        }
        return _results;
      });
    };

    CropBox.prototype.draw = function(ctx) {
      this.drawScreen(ctx);
      this.drawCropLines(ctx);
      return this.drawHandles(ctx);
    };

    return CropBox;

  })(Drawable);

  Stage = (function(_super) {
    __extends(Stage, _super);

    function Stage() {
      _ref1 = Stage.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Stage.prototype.initialize = function(options) {
      return this.canvas = options.canvas;
    };

    Stage.prototype.frame = function() {
      return {
        x: 0,
        y: 0,
        w: this.canvas.width,
        h: this.canvas.height
      };
    };

    Stage.prototype.bounds = function() {
      return this.frame();
    };

    Stage.prototype.onCanvasSizeChange = function() {
      var child, _j, _len1, _ref2, _results;
      Stage.__super__.onCanvasSizeChange.call(this);
      _ref2 = this.children;
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        child = _ref2[_j];
        _results.push(child.onCanvasSizeChange());
      }
      return _results;
    };

    Stage.prototype.draw = function(ctx) {
      return this.drawChildren(ctx);
    };

    Stage.prototype.clear = function(ctx) {
      return ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    return Stage;

  })(Drawable);

  window.RodeoCrop = (function() {
    function RodeoCrop(el, options) {
      this.el = _.isString(el) ? document.querySelector(el) : el;
      this.options = _.extend({
        cropEnabled: true,
        cropX: null,
        cropY: null,
        cropWidth: null,
        cropHeight: null,
        width: 100,
        height: 100,
        imageSource: null,
        onCropFrameChanged: null
      }, options);
      this.valid = false;
      this.ctx = null;
      this.stage = null;
      this.imageSource = this.options.imageSource;
      this.initializeCanvas();
      this.createStage();
      this.createImage();
      this.createCropBox();
      this.attachListeners();
      this.runLoop();
    }

    RodeoCrop.prototype.initializeCanvas = function() {
      this.canvas = document.createElement('canvas');
      this.canvas.width = this.options.width;
      this.canvas.height = this.options.height;
      this.el.appendChild(this.canvas);
      return this.ctx = this.canvas.getContext('2d');
    };

    RodeoCrop.prototype.createStage = function() {
      return this.stage = new Stage({
        canvas: this.canvas
      });
    };

    RodeoCrop.prototype.createImage = function() {
      var _this = this;
      this.image = new CanvasImage({
        canvas: this.canvas,
        source: this.imageSource,
        onLoad: function() {
          _this.valid = false;
          _this.image.resizeToParent();
          _this.image.centerOnParent();
          return _this.cropBox.updateFrameFromCropArea();
        },
        onCanvasSizeChange: function() {
          _this.image.resizeToParent();
          return _this.image.centerOnParent();
        }
      });
      return this.stage.addChild(this.image);
    };

    RodeoCrop.prototype.createCropBox = function() {
      var _this = this;
      this.cropBox = new CropBox({
        canvas: this.canvas,
        image: this.image,
        cropX: this.options.cropX,
        cropY: this.options.cropY,
        cropWidth: this.options.cropWidth,
        cropHeight: this.options.cropHeight,
        onCropFrameChanged: function(cropFrame) {
          var _base;
          return typeof (_base = _this.options).onCropFrameChanged === "function" ? _base.onCropFrameChanged(cropFrame) : void 0;
        }
      });
      return this.image.addChild(this.cropBox);
    };

    RodeoCrop.prototype.attachListeners = function() {
      var globalToCanvas,
        _this = this;
      globalToCanvas = function(e) {
        var rect, x, y;
        rect = _this.canvas.getBoundingClientRect();
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
        return {
          x: x,
          y: y
        };
      };
      window.addEventListener('mouseup', function(e) {
        var pos;
        pos = globalToCanvas(e);
        if (_this.dragging) {
          _this.dragging.onDragEnd(pos);
          _this.dragging.onMouseUp(pos);
        } else if (_this.mouseDown) {
          _this.mouseDown.onMouseUp(pos);
          _this.mouseDown.onClick(pos);
        } else {
          pos = globalToCanvas(e);
          if (_this.cropBox.containsCanvasPoint(pos)) {
            _this.cropBox.onMouseUp(pos);
          }
        }
        return _this.dragging = _this.mouseDown = null;
      });
      window.addEventListener('mousedown', function(e) {
        var pos;
        pos = globalToCanvas(e);
        if (_this.cropBox.containsCanvasPoint(pos)) {
          _this.mouseDown = _this.cropBox;
          return _this.cropBox.onMouseDown(pos);
        }
      });
      return window.addEventListener('mousemove', function(e) {
        var cropboxContainsPoint, pos, _base, _base1, _base2, _ref2;
        if (_this.dragging || _this.mouseDown) {
          pos = globalToCanvas(e);
          if (!_this.dragging) {
            _this.dragging = _this.mouseDown;
            _this.dragging.onDragStart(pos);
          }
          _this.dragging.onDragMove(pos);
          return _this.valid = false;
        } else {
          pos = globalToCanvas(e);
          cropboxContainsPoint = _this.cropBox.containsCanvasPoint(pos);
          if (cropboxContainsPoint && _this.mouseOver !== _this.cropBox) {
            if (_this.mouseOver) {
              if ((_ref2 = _this.mouseOver) != null) {
                _ref2.onMouseOut(pos);
              }
            }
            _this.mouseOver = _this.cropBox;
            return typeof (_base = _this.cropBox).onMouseIn === "function" ? _base.onMouseIn(pos) : void 0;
          } else if (cropboxContainsPoint && _this.mouseOver === _this.cropBox) {
            return typeof (_base1 = _this.cropBox).onMouseMove === "function" ? _base1.onMouseMove(pos) : void 0;
          } else if (!cropboxContainsPoint && _this.mouseOver === _this.cropBox) {
            if (typeof (_base2 = _this.mouseOver).onMouseOut === "function") {
              _base2.onMouseOut(pos);
            }
            return _this.mouseOver = null;
          }
        }
      });
    };

    RodeoCrop.prototype.setCropFrame = function(frame) {
      this.cropBox.setCropAreaAndUpdateFrame(frame);
      return this.valid = false;
    };

    RodeoCrop.prototype.updateCanvasSize = function() {
      var h, w;
      w = window.getComputedStyle(this.canvas.parentNode).getPropertyValue('width');
      h = window.getComputedStyle(this.canvas.parentNode).getPropertyValue('height');
      w = parseInt(w, 10);
      h = parseInt(h, 10);
      if (this.canvas.width !== w || this.canvas.height !== h) {
        this.canvas.width = w;
        this.canvas.height = h;
        return true;
      } else {
        return false;
      }
    };

    RodeoCrop.prototype.runLoop = function(arg) {
      var canvasSizeChanged,
        _this = this;
      canvasSizeChanged = this.updateCanvasSize();
      if (canvasSizeChanged) {
        this.valid = false;
      }
      if (!this.valid) {
        this.stage.clear(this.ctx);
        if (canvasSizeChanged) {
          this.stage.onCanvasSizeChange();
        }
        this.stage.draw(this.ctx);
      }
      this.valid = true;
      return window.requestAnimationFrame(function() {
        return _this.runLoop();
      });
    };

    return RodeoCrop;

  })();

}).call(this);
